# Hydro 整体架构设计文档

## 1. 项目概述

Hydro 是一个高效的信息学在线测评系统，具有易安装、跨平台、多功能、可扩展的特点。系统采用模块化设计，支持插件系统，能够满足不同规模和需求的在线测评场景。

### 1.1 核心特性

- **模块化插件系统**：基于 Cordis 框架的插件架构，支持功能热插拔
- **多租户支持**：单系统多空间设计，支持不同班级/院校分开管理
- **分布式评测**：支持多节点评测，自动负载均衡
- **全题型支持**：传统题、Special Judge、交互题、客观题等
- **跨平台兼容**：支持主流 Linux 发行版和 arm64 架构

## 2. 架构总览

### 2.1 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     Hydro System                           │
├─────────────────────────────────────────────────────────────┤
│                    Web Interface                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Frontend   │  │   Backend    │  │   Plugins    │     │
│  │  (ui-default)│  │  (hydrooj)   │  │  (Modules)   │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
├─────────────────────────────────────────────────────────────┤
│                 Core Framework                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Cordis     │  │   Serializer │  │   Validator  │     │
│  │  Framework   │  │    System    │  │    System    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
├─────────────────────────────────────────────────────────────┤
│                   Service Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Database   │  │   Storage    │  │   Judge      │     │
│  │   Service    │  │   Service    │  │   Service    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
├─────────────────────────────────────────────────────────────┤
│                Infrastructure Layer                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   MongoDB    │  │   File       │  │   Message    │     │
│  │   Database   │  │   Storage    │  │   Queue      │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术栈

- **后端语言**：TypeScript/Node.js
- **前端框架**：React + Stylus
- **数据库**：MongoDB
- **消息队列**：MongoDB 集合
- **文件存储**：本地文件系统/分布式存储
- **评测环境**：Docker/Sandbox

## 3. 核心模块设计

### 3.1 框架层 (Framework)

框架层为整个系统提供了坚实的基础，通过插件化、服务化的方式解耦业务逻辑。

#### 3.1.1 Cordis 框架
- **功能**：基于 Koishi 的 Cordis 框架，提供插件生命周期管理、依赖注入（DI）、和事件系统。它是 Hydro 模块化设计的核心。
- **核心文件**：`packages/hydrooj/src/context.ts` (核心上下文实现) 及 `framework/framework/` (框架基础)
- **代码流程与关键特性**：
  - **上下文 (Context)**：`Context` 是框架的核心，它作为容器管理所有服务和插件。
  - **服务 (Service)**：服务是可以被注入到其他服务或插件中的可复用组件。例如，`DatabaseService`。服务在启动时通过 `ctx.plugin(ServiceClass, config)` 进行注册。
  - **依赖注入 (DI)**：通过 `ctx.inject(['service1', 'service2'], (ctx) => { ... })` 来安全地访问其他服务，确保了服务间的松耦合和正确的加载顺序。
  - **生命周期**：插件可以监听生命周期事件，如 `ready`（所有插件加载完成）、`dispose`（插件卸载），来执行初始化和清理操作。

#### 3.1.2 序列化系统
- **功能**：主要负责将后端数据（尤其是API响应）转换为前端需要的格式。
- **文件位置**：`framework/framework/src/serializer.ts`
- **代码流程**：
  1. 当一个 Handler 方法执行完毕并返回数据时，`WebService` 会调用序列化器。
  2. 序列化器会根据预定义的规则（或数据本身携带的元信息）对数据进行处理，例如格式化日期、过滤敏感信息、转换数据结构等。
  3. 最终生成标准的 JSON 格式响应给前端。

#### 3.1.3 验证系统
- **功能**：基于 `schemastery` 库，提供强大的数据结构定义和验证功能，确保了 API 输入的健壮性。
- **文件位置**：`framework/framework/src/validator.ts`
- **代码流程**：
  1. 在 Handler 的方法上，通过装饰器（如 `@Query('key', Schema.string())`）来定义期望的输入参数及其类型。
  2. 当请求进入时，`WebService` 在调用具体的 Handler 方法之前，会先使用 `validator` 服务对请求中的参数（query, body等）进行校验。
  3. 如果数据不符合预定义的 `Schema`，验证系统会直接抛出 `ValidationError`，请求被中断，并返回 400 错误，从而避免了无效数据进入业务逻辑层。

### 3.2 核心系统 (HydroOJ)

核心系统是业务功能的主要实现，包含了用户、题目、比赛等核心业务逻辑。

#### 3.2.1 Handler 系统
- **功能**：作为 Controller 层，直接处理来自前端的 HTTP 请求，并调用 Model 和 Service 完成业务操作。
- **文件位置**：`packages/hydrooj/src/handler/`
- **代码流程**：
  1. 一个 HTTP 请求（如 `GET /problem/123`）根据路由规则被 `WebService` 定位到对应的 Handler 类（如 `ProblemHandler`）和方法（如 `get(id: string)`）。
  2. Handler 方法首先使用**验证系统**确保传入参数 `id` 的合法性。
  3. 调用 **Model 系统**的方法（如 `problem.get(id)`）来获取数据。
  4. Model 返回数据后，Handler 直接将其返回。
  5. **WebService** 和 **序列化系统** 接管后续流程，将数据处理后发送给前端。

#### 3.2.2 Model 系统
- **功能**：作为 Model 层，封装了所有与数据库的直接交互，定义了数据结构并实现了核心的业务逻辑。
- **文件位置**：`packages/hydrooj/src/model/`
- **代码流程**：
  1. Handler 或 Service 需要操作数据时，会调用 Model 提供的方法（如 `problem.create(data)`）。
  2. Model 方法内部会操作数据库集合（如 `this.db.collection('problem').insertOne(data)`）。
  3. 它封装了复杂的数据库操作，如聚合查询、事务等，并对数据进行加工处理。
  4. 完成数据库操作后，将结果（如新创建文档的 ID）返回给调用方。

#### 3.2.3 Service 系统
- **功能**：提供与具体业务无关的、可复用的基础服务，如数据库连接、文件存储、后台任务等。
- **文件位置**：`packages/hydrooj/src/service/`
- **代码流程**：
  - **启动时**：在系统启动阶段（`entry/worker.ts`），所有核心服务会被实例化并注册到 `Context` 中。例如 `ctx.plugin(MongoService, config)` 会建立与 MongoDB 的连接池。
  - **运行时**：其他任何模块（如 Model）都可以通过依赖注入（`ctx.inject(['db'], (ctx) => ...)`）来获取这些服务实例，并使用它们提供的能力（如 `ctx.db.collection(...)`）。

### 3.3 评测系统 (HydroJudge)

评测系统是 Hydro 的关键组成部分，负责代码的编译、执行和结果判断。

#### 3.3.1 评测流程
- **文件位置**：`packages/hydrojudge/src/`
- **代码流程**：
  1. **入队**：用户在前端提交代码，后端 `record` handler 创建一条记录，状态为 `pending`，并将其作为一个任务（task）插入到 MongoDB 的 `task` 集合中。
  2. **拉取**：`hydrojudge` 作为一个独立的守护进程 (`daemon.ts`) 运行，它会定期轮询 `task` 集合，获取 `pending` 状态的任务。
  3. **执行**：获取任务后，`daemon` 会创建一个 `Task` 实例 (`task.ts`) 来处理这个评测。
  4. **编译与运行**：`Task` 实例调用 `compile.ts` 编译代码，然后根据题目类型选择对应的评测器（如 `judge/default.ts`）在沙箱 (`sandbox/`) 中执行代码。
  5. **结果处理**：沙箱会限制代码的资源消耗（CPU、内存），并捕获其输出。评测器将程序输出与标准答案进行比对。
  6. **更新**：评测完成后，`Task` 实例将评测结果（如 `Accepted`, `Wrong Answer` 等）和资源消耗信息更新回数据库中对应的 `record` 记录。
  7. **通知**：前端通过 WebSocket 或轮询得知 `record` 状态变化，并向用户展示最终结果。

### 3.4 用户界面 (UI-Default)

UI-Default 是 Hydro 的默认前端实现，为用户提供了与系统交互的界面。

#### 3.4.1 数据交互流程
- **文件位置**：`packages/ui-default/pages/`
- **代码流程**：
  1. **页面加载**：浏览器打开一个页面，例如题目详情页，对应的 React 组件 (`problem_view.page.tsx`) 开始渲染。
  2. **数据请求**：在组件的 `useEffect` Hook 中，会调用一个预定义的 API 请求函数（例如 `api.problem.get({ pid: 'P1000' })`）。
  3. **API 调用**：这个请求函数会向后端对应的 Handler（`GET /problem/P1000`）发起一个 HTTP 请求。
  4. **状态管理**：请求返回的数据通过 React 的 `useState` 或 `useSWR` 等 Hook 更新到组件的 state 中。
  5. **界面渲染**：state 的变化触发组件的重新渲染，将题目信息展示在页面上。
  6. **用户操作**：用户的操作（如提交代码）会触发事件处理器，调用其他的 API 请求函数（如 `api.record.submit(...)`）将新数据发送到后端。

### 3.5 代码启动流程

Hydro 的后端服务启动过程清晰且模块化，以下是核心步骤：

1.  **脚本执行**:
    - `yarn start` 命令执行 `packages/hydrooj/bin/hydrooj.js` 脚本。
    - `yarn debug` 与 `start` 类似，但增加了 Node.js 的调试参数。

2.  **命令解析**:
    - `hydrooj.js` 初始化 `@hydrooj/register` 进行模块路径注册，然后执行 `commands.ts`。
    - `commands.ts` 使用 `cac` 库解析命令行参数。对于正常的启动，它会调用 `require('../src/loader').load()`。

3.  **加载器 (Loader)**:
    - `packages/hydrooj/src/loader.ts` 中的 `load()` 函数是应用启动的核心入口。
    - 它首先执行 `preload()` 进行预加载，然后调用 `require('./entry/worker').apply(app)` 来启动主工作进程。

4.  **工作进程 (Worker) 初始化**:
    - `packages/hydrooj/src/entry/worker.ts` 的 `apply` 函数负责初始化所有核心服务。
    - **数据库连接**：它首先通过 `MongoService.getUrl()` 检查数据库配置。如果配置不存在，则会启动交互式的设置流程 (`./setup.ts`)。
    - **服务插件化**：随后，它使用 `ctx.plugin()` 方法，按顺序加载并初始化一系列核心服务：
        - `MongoService`: 建立数据库连接。
        - `SettingService`: 从数据库加载系统配置。
        - `StorageService`: 初始化文件存储服务（本地或 S3）。
        - `ServerService`: 初始化 Web 服务。
        - 其他如 `WorkerService`, `BusService` 等。

5.  **Web 服务启动**:
    - `packages/hydrooj/src/service/server.ts` 在被加载时，会配置并启动 `@hydrooj/framework` 中的 `WebService`。
    - `WebService` 内部封装了 `Koa` 服务器。它会从配置中（`system.get('server.host')` 和 `system.get('server.port')`）读取监听的主机和端口号。
    - 这些配置最初来源于 `~/.hydro/config.json` 文件和数据库。
    - 最后，`WebService` 调用 `listen()` 方法，启动 HTTP 服务器，开始接收外部请求。

## 4. 数据流设计

### 4.1 请求处理流程

```
Request → Router → Handler → Model → Database
   ↓         ↓        ↓       ↓        ↓
Response ← Serializer ← Business Logic ← Data
```

### 4.2 评测流程

```
Submit → Queue → Judge → Sandbox → Result
  ↓        ↓       ↓       ↓         ↓
Database ← Status ← Compile ← Execute ← Update
```

### 4.3 插件系统

```
Core System → Plugin Manager → Plugin Loader → Plugin Instance
     ↓             ↓              ↓               ↓
Event Bus ← Dependency Injection ← Lifecycle ← Implementation
```

## 5. 部署架构

### 5.1 单机部署

```
┌─────────────────────────────────────┐
│           Single Server             │
├─────────────────────────────────────┤
│  ┌───────────┐  ┌───────────┐      │
│  │   Hydro   │  │  MongoDB  │      │
│  │  Backend  │  │ Database  │      │
│  └───────────┘  └───────────┘      │
│  ┌───────────┐  ┌───────────┐      │
│  │   Judge   │  │   File    │      │
│  │  Service  │  │  Storage  │      │
│  └───────────┘  └───────────┘      │
└─────────────────────────────────────┘
```

### 5.2 分布式部署

```
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   Web Server    │  │   Web Server    │  │   Web Server    │
│   (Frontend)    │  │   (Frontend)    │  │   (Frontend)    │
└─────────────────┘  └─────────────────┘  └─────────────────┘
         │                     │                     │
         └─────────────────────┼─────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                    Load Balancer                           │
└─────────────────────────────────────────────────────────────┘
         │                     │                     │
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   App Server    │  │   App Server    │  │   App Server    │
│   (Backend)     │  │   (Backend)     │  │   (Backend)     │
└─────────────────┘  └─────────────────┘  └─────────────────┘
         │                     │                     │
         └─────────────────────┼─────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                   MongoDB Cluster                          │
└─────────────────────────────────────────────────────────────┘
         │                     │                     │
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   Judge Node    │  │   Judge Node    │  │   Judge Node    │
│   (Evaluator)   │  │   (Evaluator)   │  │   (Evaluator)   │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

## 6. 安全设计

### 6.1 权限系统

- **分层权限**：全局权限、域权限、角色权限
- **权限节点**：细粒度权限控制
- **用户组**：基于组的权限管理

### 6.2 安全措施

- **输入验证**：所有用户输入都经过验证
- **XSS 防护**：内容过滤和转义
- **CSRF 防护**：Token 验证
- **SQL 注入防护**：参数化查询
- **沙箱隔离**：评测环境完全隔离

## 7. 性能优化

### 7.1 数据库优化

- **索引策略**：关键字段建立索引
- **查询优化**：避免 N+1 查询
- **分页优化**：游标分页
- **缓存策略**：热点数据缓存

### 7.2 系统优化

- **连接池**：数据库连接复用
- **静态资源**：CDN 加速
- **压缩传输**：Gzip 压缩
- **异步处理**：非阻塞 I/O

## 8. 监控与日志

### 8.1 监控系统

- **系统监控**：CPU、内存、磁盘使用率
- **应用监控**：请求量、响应时间、错误率
- **业务监控**：用户活跃度、题目提交量

### 8.2 日志系统

- **访问日志**：记录所有 HTTP 请求
- **操作日志**：记录重要操作
- **错误日志**：记录系统错误
- **评测日志**：记录评测过程

## 9. 扩展性设计

### 9.1 插件系统

- **标准接口**：统一的插件接口
- **生命周期**：插件加载、卸载管理
- **依赖管理**：插件间依赖关系
- **热更新**：无需重启的插件更新

### 9.2 API 设计

- **RESTful API**：标准 REST 接口
- **GraphQL**：灵活的查询接口
- **WebSocket**：实时通信
- **版本控制**：API 版本管理

## 10. 总结

Hydro 系统采用了现代化的微服务架构设计，具有良好的可扩展性和可维护性。通过模块化的插件系统，系统能够灵活适应不同的业务需求。分布式的部署架构保证了系统的高可用性和可扩展性。完善的安全机制和性能优化策略确保了系统的稳定运行。